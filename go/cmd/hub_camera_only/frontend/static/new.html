<!DOCTYPE html>
<html>
<head>
    <title>RTSP Stream Viewer</title>
    <style>
        .container {
            max-width: 800px;
            margin: 20px auto;
            text-align: center;
        }
        video {
            width: 100%;
            max-width: 800px;
            border: 1px solid #ccc;
        }
        #status {
            margin: 10px 0;
            padding: 10px;
            background: #f0f0f0;
        }
        .debug {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }
    </style>
</head>
<body>
<div class="container">
    <video id="videoPlayer" controls autoplay playsinline></video>
    <div id="status">Initializing...</div>
    <div id="debug" class="debug"></div>
</div>

<script>
    const video = document.getElementById('videoPlayer');
    const status = document.getElementById('status');
    const debug = document.getElementById('debug');
    let mediaSource = null;
    let sourceBuffer = null;
    let ws = null;
    let isSourceBufferValid = false;
    let bufferQueue = [];
    const MAX_BUFFER_SIZE = 30; // Maximum number of chunks to queue
    const BUFFER_THRESHOLD = 4; // Seconds of buffer to maintain

    function showStatus(message) {
        status.textContent = message;
        updateDebugInfo();
    }

    function updateDebugInfo() {
        if (sourceBuffer && isSourceBufferValid) {
            const ranges = sourceBuffer.buffered;
            let bufferedSeconds = 0;
            if (ranges.length > 0) {
                bufferedSeconds = ranges.end(ranges.length - 1) - video.currentTime;
            }
            debug.textContent = `Buffer: ${bufferedSeconds.toFixed(1)}s, Queue: ${bufferQueue.length}`;
        }
    }

    function cleanupMediaSource() {
        bufferQueue = [];
        if (sourceBuffer && mediaSource && mediaSource.readyState === 'open') {
            isSourceBufferValid = false;
            try {
                mediaSource.removeSourceBuffer(sourceBuffer);
            } catch (e) {
                console.log('Error removing source buffer:', e);
            }
        }
        if (mediaSource && mediaSource.readyState === 'open') {
            try {
                mediaSource.endOfStream();
            } catch (e) {
                console.log('Error ending media stream:', e);
            }
        }
        sourceBuffer = null;
        mediaSource = null;
    }

    function processBufferQueue() {
        if (!isSourceBufferValid || !sourceBuffer || sourceBuffer.updating) {
            return;
        }

        // Process queued buffers
        while (bufferQueue.length > 0 && !sourceBuffer.updating) {
            const buffer = bufferQueue.shift();
            try {
                sourceBuffer.appendBuffer(buffer);
            } catch (e) {
                console.error('Error appending buffer:', e);
                if (isSourceBufferValid && !sourceBuffer.updating) {
                    try {
                        sourceBuffer.remove(0, video.currentTime - BUFFER_THRESHOLD);
                    } catch (removeError) {
                        console.warn('Buffer removal failed:', removeError);
                    }
                }
            }
        }

        updateDebugInfo();
    }

    function startPlayback() {
        cleanupMediaSource();

        mediaSource = new MediaSource();
        video.src = URL.createObjectURL(mediaSource);

        mediaSource.addEventListener('sourceopen', () => {
            showStatus('MediaSource opened, connecting to WebSocket...');

            try {
                sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
                sourceBuffer.mode = 'sequence';
                isSourceBufferValid = true;

                sourceBuffer.addEventListener('updateend', processBufferQueue);

                // Set initial video buffer size
                video.bufferSize = 2; // Buffer size in seconds

                connectWebSocket();
            } catch (e) {
                showStatus('Error setting up video player: ' + e.message);
                cleanupMediaSource();
            }
        });

        // ... [previous event listeners remain the same] ...
    }

    function connectWebSocket() {
        if (ws) {
            ws.close();
        }

        ws = new WebSocket(`ws://${window.location.hostname}:8082/ws`);

        ws.onopen = () => {
            showStatus('Connected to stream');
        };

        ws.onmessage = async (event) => {
            if (!(event.data instanceof Blob)) return;

            try {
                const buffer = await event.data.arrayBuffer();

                // Queue management
                if (bufferQueue.length < MAX_BUFFER_SIZE) {
                    bufferQueue.push(buffer);
                    if (!sourceBuffer.updating) {
                        processBufferQueue();
                    }
                } else {
                    console.warn('Buffer queue full, dropping chunk');
                }
            } catch (e) {
                console.error('Error processing video chunk:', e);
            }
        };

        // ... [previous ws event handlers remain the same] ...
    }

    // Handle page visibility
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            if (ws) {
                ws.close();
            }
            cleanupMediaSource();
        } else {
            startPlayback();
        }
    });

    // Monitor playback stats
    setInterval(updateDebugInfo, 1000);

    // Start playback
    startPlayback();
</script>
</body>
</html>